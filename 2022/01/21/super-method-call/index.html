<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="../../../../favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
	<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-c3600b88.css">
	<link rel="modulepreload" href="/_app/start-800dd27f.js">
	<link rel="modulepreload" href="/_app/chunks/vendor-21bfd96e.js">
	<link rel="modulepreload" href="/_app/chunks/preload-helper-ec9aa979.js">
	<link rel="modulepreload" href="/_app/pages/__layout.svelte-6f843764.js">
	<link rel="modulepreload" href="/_app/pages/_yyyy_/_mm_/_dd_/_slug_.svelte-d12c06c3.js">
	<link rel="modulepreload" href="/_app/chunks/allPosts-b87e59f1.js">
			<script type="module">
				import { start } from "/_app/start-800dd27f.js";
				start({
					target: document.querySelector("body"),
					paths: {"base":"","assets":""},
					session: {},
					route: true,
					spa: false,
					trailing_slash: "always",
					hydrate: {
						status: 200,
						error: null,
						nodes: [
							import("/_app/pages/__layout.svelte-6f843764.js"),
						import("/_app/pages/_yyyy_/_mm_/_dd_/_slug_.svelte-d12c06c3.js")
						],
						url: new URL("http://prerender/2022/01/21/super-method-call/"),
						params: {yyyy:"2022",mm:"01",dd:"21",slug:"super-method-call"}
					}
				});
			</script>
	</head>
	<body>
		


<header class="bg-gray-100 py-4"><a href="/" class="m-4 font-semibold">Home</a></header>
<div class="main-width mt-8 mb-16 svelte-1shbde4"><h1 class="text-4xl">Calling Superclass Methods</h1>

<p class="text-sm italic">Published 1/21/2022
	- last edited: 1/22/2022</p>

<ul class="text-sm m-0 list-none flex flex-wrap gap-1"><li class="m-0"><a href="/categories/java" class="bg-gray-200 px-1">Java</a>
		</li></ul>

<p>When creating a subclass, a common situation is to overwrite a method, but using the original class’ logic in doing so.
Let’s say we have a class for sending messages, and we want to make a variant that is written in a more formal style.
In doing so, we want to preserve the “simple message formatting” logic that the superclass implements.
A simple approach could look like this:</p>
<pre class="language-java"><!-- HTML_TAG_START --><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> content<span class="token punctuation">;</span>

	<span class="token comment">// ... constructor &amp; getters ...</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// simple message formatting</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">FormalMessage</span> <span class="token keyword">extends</span> <span class="token class-name">Message</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token class-name">FormalMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> sender<span class="token punctuation">,</span> <span class="token class-name">String</span> receiver<span class="token punctuation">,</span> <span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// formal message formatting</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dear "</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sincerely, "</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p>This might look alright: when overriding <code>send</code>, we need to use <code>super.send()</code> to avoid an accidental recursion.
For consistency, why not also use <code>super.getReceiver()</code>?
Well, consider this extension:</p>
<pre class="language-java"><!-- HTML_TAG_START --><code class="language-java"><span class="token keyword">class</span> <span class="token keyword">extends</span> <span class="token class-name">FormalIncognitoMessage</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token class-name">FormalIncognitoMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> sender<span class="token punctuation">,</span> <span class="token class-name">String</span> receiver<span class="token punctuation">,</span> <span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">"Anonymous"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<pre class="language-java"><!-- HTML_TAG_START --><code class="language-java">		<span class="token class-name">Message</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormalIncognitoMessage</span><span class="token punctuation">(</span><span class="token string">"SillyFreak"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">,</span> <span class="token string">"Hello."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		m<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Dear World,</span>
		<span class="token comment">// Hello.</span>
		<span class="token comment">// Sincerely, SillyFreak</span></code><!-- HTML_TAG_END --></pre>
<p>What happened here? Well, that <code>super</code> is not only special in an overridden method, it generally fixes the implementation of the method to use to that of the superclass.</p>
<p>A regular non-static method call in Java uses “dynamic dispatch”: at runtime, the class of the object the method is called on is used to determine what variant is called.
For example, <code>formalMessage.getSender()</code> uses the implementation in <code>Message</code>, because it wasn’t overwritten.
<code>formalMessage.send()</code> would use the implementation in <code>FormalMessage</code>.</p>
<p>But <code>super.getSender()</code> uses “static dispatch” instead.
That code is located in class <code>FormalMessage</code>, so <code>super</code> refers to class <code>Message</code> - even if the actual object is of type <code>FormalIncognitoMessage</code> and that type’s superclass would be <code>FormalMessage</code>.
So the <code>getSender()</code> implementation of <code>Message</code> is used, even if there is a more specific one as well.</p>
<h1>Method calls on the bytecode level</h1>
<p>So <code>super</code> works differently - that means we should be able to spot the difference in the compiled code, and indeed we can.
Let’s create a more simplified example for looking at this:</p>
<pre class="language-java"><!-- HTML_TAG_START --><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<p>If we compile this and then look at <code>B</code>’s bytecode:</p>
<pre class="language-shell"><!-- HTML_TAG_START --><code class="language-shell">javac *.java
javap -c B.class</code><!-- HTML_TAG_END --></pre>
<p>We get this:</p>
<pre class="language-bytecode"><!-- HTML_TAG_START --><code class="language-bytecode">  public void bar();
    Code:
       0: aload_0
       1: invokevirtual #7                  // Method foo:()V
       4: aload_0
       5: invokespecial #12                 // Method A.foo:()V
       8: return</code><!-- HTML_TAG_END --></pre>
<p>We can roughly read this as (for a more proper understanding, take a look at <a href="https://en.wikipedia.org/wiki/Stack_machine" rel="nofollow">stack machines</a>, of which the JVM is an example):</p>
<ul><li>Load the <code>this</code> object (<code>aload_0</code>).</li>
<li>On that object, do a regular dynamic method call to <code>void foo()</code>.
The word “virtual” here refers to the fact that this is implemented by using a <a href="https://en.wikipedia.org/wiki/Virtual_method_table" rel="nofollow">virtual function table</a> or vtable.
The <code>#7</code> here is an index at which the method name <code>foo</code> and signature <code>()V</code> are stored within the class file.</li>
<li>The <code>this</code> was “consumed” by that call, so load it again for the second call.</li>
<li>On this object, do a “special” method call to that same method.
Note how the method is specified as <code>A.foo:()V</code>:
the class to search for <code>foo</code> is compiled into this instruction instead of determined from <code>this</code> at runtime.</li>
<li>Finally, the method returns to the caller, whoever that was.
We don’t write that return in Java (for <code>void</code> methods), but at the JVM level it’s a important part of what a method does.</li></ul>
<p>There are other kinds of method calls in the JVM.
They are not the topic here, but if you’re interested, try calling static methods and constructors, or this surprisingly intricate piece of code:</p>
<pre class="language-java"><!-- HTML_TAG_START --><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre>
<h1>Conclusion</h1>
<p>Being able to call <code>super.foo()</code> is important, but basically only meant for situations where a class overrides that method <code>foo</code>; on <em>inherited</em> methods, using <code>super</code> is almost always a mistake.
The difference between <code>this.foo();</code> and <code>super.foo();</code> is bigger than it may first seem and may lead to surprising behavior later on - so it’s important to avoid mixing the two up from the start.</p></div>
<footer class="bg-gray-100 py-4"> </footer>


	</body>
</html>
